<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from src/site/apt/multimodule/multimodule_strategy.apt.vm at 2026-01-18
 | Rendered using Apache Maven Fluido Skin 2.1.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>AspectJ in a multi-module reactor – Mojo&apos;s AspectJ Maven Plugin</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-2.1.0.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-2.1.0.min.js"></script>
    <!-- Matomo -->
    <script>
        var _paq = window._paq = window._paq || [];
        _paq.push(['disableCookies']);
        _paq.push(['trackPageView']);
        _paq.push(['enableLinkTracking']);

        (function() {
            var u="https://analytics.apache.org/";
            _paq.push(['setTrackerUrl', u+'/matomo.php']);
            _paq.push(['setSiteId', '18']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'/matomo.js'; s.parentNode.insertBefore(g,s);
        })();
    </script>
    <!-- End Matomo Code -->
    <style>.github-fork-ribbon:before { background-color: gray; }</style>
  </head>
  <body>
    <a class="github-fork-ribbon right-top" href="https://github.com/mojohaus/aspectj-maven-plugin" data-ribbon="Fork me on GitHub">Fork me on GitHub</a>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1><a href="../../../"><img src="../../../images/mojo_logo.png" alt="MojoHaus" /></a></h1></div></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
      <li><a href="../../../">MojoHaus</a><span class="divider">/</span></li>
      <li><a href=".././">Mojo&apos;s AspectJ Maven Plugin</a><span class="divider">/</span></li>
    <li class="active">AspectJ in a multi-module reactor <a href="https://github.com/mojohaus/aspectj-maven-plugin/src/site/apt/multimodule/multimodule_strategy.apt.vm"><img src="../images/accessories-text-editor.png" alt="Edit" /></a></li>
        <li id="publishDate" class="pull-right"><span class="divider">|</span> Last Published: 2026-01-18</li>
          <li id="projectVersion" class="pull-right"><span class="divider">|</span>Version: 1.16.0</li>
        <li class="pull-right"><span class="divider">|</span>
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html">AJC Documentation</a></li>
        <li class="pull-right"><span class="divider">|</span>
<a href="https://www.eclipse.org/aspectj/">AspectJ</a></li>
        <li class="pull-right"><a href="https://maven.apache.org/">Maven</a></li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="../index.html">Introduction</a></li>
    <li><a href="../usage.html">Usage</a></li>
    <li><a href="../plugin-info.html">Goals</a></li>
   <li class="nav-header">Examples: Single-project AspectJ use</li>
    <li><a href="../examples/differentTestAndCompile.html">Separate test/compile settings</a></li>
    <li><a href="../examples/includeExclude.html">Using includes/excludes</a></li>
    <li><a href="../examples/usingTogetherWithAJDT.html">Using with AJDT</a></li>
    <li><a href="../examples/weaveJars.html">Weaving classes in jars</a></li>
    <li><a href="../examples/weaveDirectories.html">Weaving classes in directories</a></li>
    <li><a href="../examples/libraryJars.html">Using aspect libraries</a></li>
    <li><a href="../examples/usingReport.html">Configuring Report</a></li>
   <li class="nav-header">Examples: Multi-module AspectJ use</li>
    <li class="active"><a>Multi-module use of AspectJ</a></li>
   <li class="nav-header">AspectJ Compiler reference</li>
    <li><a href="../ajc_reference/standard_opts.html">AJC standard options</a></li>
    <li><a href="../ajc_reference/experimental_opts.html">AJC experimental options</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><a id="Strategies_for_using_AspectJ_in_a_Maven_multi-module_reactor"></a>
<h1>Strategies for using AspectJ in a Maven multi-module reactor</h1>
<p>In a multi-module reactor, a convenient pattern for using AspectJ is to create one project containing Aspect definitions to be used by (&quot;woven into&quot;) the code of other projects within the Maven reactor. Since some dependencies (such as the AspectJ runtime) must be identical in all of the projects within the Maven reactor, this walkthrough serves as a step-by-step guide to painless use of aspects in a multi-module reactor.</p>
<p>To make this walkthrough less abstract, we will use Validation as an example throughout the step-by-step guide. In this example, we will create a small API for validating the internal state of objects, and delegate its correct use to AspectJ by means of the AspectJ Maven Plugin. There are many ways besides AspectJ to perform this, but AspectJ is one of the few which does not depend on particular surroundings such as containers or application servers. In fact, the small Validation solution may be run directly in a plain Java SE environment. All steps will be detailed in the walkthrough below, but we will start by taking a look at the end result:</p>
<p>The reactor contains the following parts:</p>
<ul>
<li><b>rootParentPOM</b>: Contains version definitions for the aspectjrt and aspectjtools libraries, to be used in all projects in the multi-module reactor.</li>
<li><b>validation-api</b>: Defines a small API for validating the internal state of objects.</li>
<li><b>validation-aspect</b>: Defines an Aspect using classes from the <code>validation-api</code> to validate the internal state of objects.</li>
<li><b>aspectParentPOM</b>: Configures the AspectJ Maven Plugin (this plugin!) to use the Aspect defined within the <code>validation-aspect</code> project and apply it on all maven projects having the aspectParentPOM for parent.</li>
<li><b>mavenProjectWithAspects</b>: A project whose classes can use/implement types from the validation-api to indicate that the aspect defined in <code>validation-aspect</code> project should be woven into its bytecode representation.
<p>After the introduction, let us proceed to the step-by-step guide.</p></li></ul><section><a id="a1._Define_required_runtime_dependency_versions"></a>
<h2>1. Define required runtime dependency versions</h2>
<p>In the rootParentPom, define dependencies for the AspectJ runtime and your library holding aspects. It is recommended to introduce a Maven property in order to reduce the number of locations where the AspectJ version must be changed to upgrade the dependency.</p>
<pre class="prettyprint"><code>      &lt;!-- +========================================= --&gt;
      &lt;!-- | Maven property definitions               --&gt;
      &lt;!-- +========================================= --&gt;
      &lt;properties&gt;
        &lt;aspectj.runtime.version&gt;1.8.2&lt;/aspectj.runtime.version&gt;

        ...
      &lt;/properties&gt;


      &lt;!-- +========================================= --&gt;
      &lt;!-- | Dependency (management) settings         --&gt;
      &lt;!-- +========================================= --&gt;
      &lt;dependencyManagement&gt;
          &lt;dependencies&gt;

            &lt;!-- AOP dependencies. --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
                &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
                &lt;version&gt;${aspectj.runtime.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
                &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
                &lt;version&gt;${aspectj.runtime.version}&lt;/version&gt;
            &lt;/dependency&gt;

            ...

          &lt;/dependencies&gt;
      &lt;/dependencyManagement&gt;
</code></pre>
<p>The definitions in the rootParentPOM are now complete.</p></section><section><a id="a2._Implement_the_Validation-API"></a>
<h2>2. Implement the Validation-API</h2>
<p>For the purpose of this example, we would like AspectJ to enforce a common behaviour/lifecycle for objects whose internal state can be validated. The Validation-API contains a defining interface, <code>Validatable</code>, which should be implemented by any class whose objects should be validated after being created. The Validatable interface is shown below:</p>
<pre class="prettyprint"><code>/**
 * Specification for providing an object with Validation mechanics.
 * Each Validatable object can perform internal validation to assert
 * its state before being serialized and after being deserialized.
 *
 * Making an object implement Validatable does not imply that all
 * uses of the object is guaranteed. Validatable objects should
 * primarily make use of their own data to ascertain its valid state.
 *
 * It is the responsibilities of services using the Validatable object
 * (as opposed to the validation mechanics provided within this Validatable)
 * to provide extra/semantic validation for object &lt;strong&gt;graphs&lt;/strong&gt;
 * in which this Validatable instance is part.
 */
public interface Validatable {

    /**
     * Performs validation of the internal state of this Validatable.
     *
     * @throws InternalStateValidationException
     *          if the state of this Validatable was
     *          in an incorrect state (i.e. invalid).
     */
    void validateInternalState() throws InternalStateValidationException;
}</code></pre>
<p>Following the definition of a custom exception class called <code>InternalStateValidationException</code> which should extends <code>IllegalStateException</code>, the small validation-api project is complete:</p>
<pre class="prettyprint"><code>/**
 * Exception indicating problems occurred when validating a Validatable instance.
 */
public class InternalStateValidationException extends IllegalStateException {

    /**
     * Constructs an InternalStateValidationException with the specified detail message.
     * A detail message is a String that describes this particular exception.
     *
     * @param message the String that contains a detailed message
     */
    public InternalStateValidationException(final String message) {
        super(message);
    }
}</code></pre>
<p>Assuming that the rootParentPOM contains common build definitions which should be applied to the validation-api project, we should remember to assign the rootParentPOM as its parent. In this brief example, we explore no reason to connect the validation-api to a parent - but in real life configurations such as licensing, coverage, code style, etc. are frequently configured and maintained only in one POM - the rootParentPOM.</p></section><section><a id="a3._Implement_the_Aspect_performing_validation"></a>
<h2>3. Implement the Aspect performing validation</h2>
<p>Now that our tiny Validation API is complete, it is time to implement its corresponding Aspect. This is done in the <code>validation-aspect</code> project, which must import the validation-api as a dependency in its POM. It is also important that the validation-aspect project assigns its POM parent to rootParentPOM, since we want to use the AspectJ definitions from the parent. The POM bits of the validation-aspect project are shown below:</p>
<pre class="prettyprint"><code>    &lt;!-- +========================================= --&gt;
    &lt;!-- | Define the Parent POM                    --&gt;
    &lt;!-- +========================================= --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;some.group.id&lt;/groupId&gt;
        &lt;artifactId&gt;rootParentPOM&lt;/artifactId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;!-- +========================================= --&gt;
    &lt;!-- | Dependency (management) settings         --&gt;
    &lt;!-- +========================================= --&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;some.group.id&lt;/groupId&gt;
            &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;

        ...
    &lt;/dependencies&gt;

    &lt;!-- +========================================= --&gt;
    &lt;!-- | Build settings                           --&gt;
    &lt;!-- +========================================= --&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.16.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;complianceLevel&gt;1.6&lt;/complianceLevel&gt;
                    &lt;includes&gt;
                        &lt;include&gt;**/*.java&lt;/include&gt;
                        &lt;include&gt;**/*.aj&lt;/include&gt;
                    &lt;/includes&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;compile_with_aspectj&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;compile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                    &lt;execution&gt;
                        &lt;id&gt;test-compile_with_aspectj&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;test-compile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
                        &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
                        &lt;version&gt;${aspectj.runtime.version}&lt;/version&gt;
                    &lt;/dependency&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
                        &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
                        &lt;version&gt;${aspectj.runtime.version}&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
            &lt;/plugin&gt;

            ...</code></pre>
<p>Besides including the correct parent POM and the required dependencies from aspectjrt and the validation-api project, the POM of the validation-aspect project must also define the full aspectj-maven-plugin configuration to perform the aspectj compilation.</p>
<p>Note that aspectjrt and aspectjtools should be included as dependencies for the aspectj-maven-plugin as illustrated here to ensure that the same versions of AspectJ used for the AspectJ compilation are used throughout the reactor.</p>
<p>The implementation of the Aspect itself can appear somewhat complex, despite only being a single active method. The main relevant method call is <code>validatable.validateInternalState();</code> which appears towards the end of the <code>performValidationAfterCompoundConstructor</code> method. This is the place where this Aspect invokes the method from the validation-api, and therefore lets the object validate its internal state. The other two methods in the aspect are placeholders for two Pointcut expressions defining exactly when the advice should be called. In this example case, we want to invoke validation after any constructor other than a default constructor is called.</p>
<pre>    Why would you not want to perform validation after a default constructor is called?
    Consider the lifecycle for frameworks which create an object instance by calling the
    default constructor of a class, followed by poulating its internal state
    (i.e. its private members) using reflection.
    Some such frameworks include JAXB and JPA, implying that validation cannot be performed
    immediately after a default constructor has been run since the state of
    the object is still empty.</pre>
<p>The aspect is implemented as a standard Java Class using AspectJ annotations, as shown below:</p>
<pre class="prettyprint"><code>/**
 * The aspect enforcing validity on a class implementing Validatable (i.e. Entities).
 * This aspect should be fired immediately after a non-default constructor is invoked,
 * and is intended to run as a singleton.
 *
 * Validation should be run only once, and only after the constructor of the ultimate
 * created instance is run (default AspectJ behaviour is to run the Aspect after any
 * constructor within the inheritance hierarchy is executed [i.e. after constructors
 * in superclasses are run, within the constructor of subtypes]).
 */
@Aspect
public class ValidationAspect {

    // Our log
    private static final Logger log = LoggerFactory.getLogger(ValidationAspect.class);

    /**
     * Pointcut defining a default constructor within any class.
     */
    @Pointcut(&quot;initialization(*.new())&quot;)
    void anyDefaultConstructor() {
    }

    /**
     * Defines a Pointcut for any constructor in a class implementing Validatable -
     * except default constructors (i.e. those having no arguments).
     *
     * @param joinPoint    The currently executing joinPoint.
     * @param aValidatable The Validatable instance just created.
     */
    @Pointcut(value = &quot;initialization(se.jguru.nazgul.tools.validation.api.Validatable+.new(..)) &quot;
            + &quot;&amp;&amp; this(aValidatable) &quot;
            + &quot;&amp;&amp; !anyDefaultConstructor()&quot;, argNames = &quot;joinPoint, aValidatable&quot;)
    void anyNonDefaultConstructor(final JoinPoint joinPoint, final Validatable aValidatable) {
    }

    /**
     * Validation aspect, performing its job after calling any constructor except
     * non-private default ones (having no arguments).
     *
     * @param joinPoint   The currently executing joinPoint.
     * @param validatable The validatable instance just created.
     * @throws InternalStateValidationException
     *          if the validation of the validatable failed.
     */
    @AfterReturning(value = &quot;anyNonDefaultConstructor(joinPoint, validatable)&quot;, argNames = &quot;joinPoint, validatable&quot;)
    public void performValidationAfterCompoundConstructor(final JoinPoint joinPoint, final Validatable validatable)
            throws InternalStateValidationException {

        if (log.isDebugEnabled()) {
            log.debug(&quot;Validating instance of type [&quot; + validatable.getClass().getName() + &quot;]&quot;);
        }

        if (joinPoint.getStaticPart() == null) {
            log.warn(&quot;Static part of join point was null for validatable of type: &quot;
                    + validatable.getClass().getName(), new IllegalStateException());
            return;
        }

        // Ignore calling validateInternalState when we execute constructors in
        // any class but the concrete Validatable class.
        final ConstructorSignature sig = (ConstructorSignature) joinPoint.getSignature();
        final Class&lt;?&gt; constructorDefinitionClass = sig.getConstructor().getDeclaringClass();
        if (validatable.getClass() == constructorDefinitionClass) {

            // Now fire the validateInternalState method.
            validatable.validateInternalState();

        } else {

            log.debug(&quot;Ignored firing validatable for constructor defined in [&quot;
                    + constructorDefinitionClass.getName() + &quot;] and Validatable of type [&quot;
                    + validatable.getClass().getName() + &quot;]&quot;);
        }
    }
}</code></pre></section><section><a id="a4._Include_Aspects_into_aspectParentPOM"></a>
<h2>4. Include Aspects into aspectParentPOM</h2>
<p>The last piece of the AspectJ plugin puzzle is the inclusion of our validation-aspect into the standard build cycle, which is performed within the aspectParentPOM project. The aspectParentPOM must therefore include a dependency on the <code>validation-aspect</code> project, and use the rootParentPOM for parent.</p>
<pre class="prettyprint"><code>    &lt;!-- +========================================= --&gt;
    &lt;!-- | Define the Parent POM                    --&gt;
    &lt;!-- +========================================= --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;some.group.id&lt;/groupId&gt;
        &lt;artifactId&gt;rootParentPOM&lt;/artifactId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;!-- +========================================= --&gt;
    &lt;!-- | Dependency (management) settings         --&gt;
    &lt;!-- +========================================= --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;some.group.id&lt;/groupId&gt;
                &lt;artifactId&gt;validation-aspect&lt;/artifactId&gt;
                &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;!-- Include AOP dependencies --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;some.group.id&lt;/groupId&gt;
            &lt;artifactId&gt;validation-aspect&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
        &lt;/dependency&gt;

        ...
    &lt;/dependencies&gt;

    &lt;!-- +========================================= --&gt;
    &lt;!-- | Build settings                           --&gt;
    &lt;!-- +========================================= --&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.16.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;complianceLevel&gt;1.6&lt;/complianceLevel&gt;
                    &lt;includes&gt;
                        &lt;include&gt;**/*.java&lt;/include&gt;
                        &lt;include&gt;**/*.aj&lt;/include&gt;
                    &lt;/includes&gt;
                    &lt;aspectDirectory&gt;src/main/aspect&lt;/aspectDirectory&gt;
                    &lt;testAspectDirectory&gt;src/test/aspect&lt;/testAspectDirectory&gt;
                    &lt;XaddSerialVersionUID&gt;true&lt;/XaddSerialVersionUID&gt;
                    &lt;showWeaveInfo&gt;true&lt;/showWeaveInfo&gt;
                    &lt;aspectLibraries&gt;
                        &lt;aspectLibrary&gt;
                            &lt;groupId&gt;some.group.id&lt;/groupId&gt;
                            &lt;artifactId&gt;validation-aspect&lt;/artifactId&gt;
                        &lt;/aspectLibrary&gt;
                    &lt;/aspectLibraries&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;compile_with_aspectj&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;compile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                    &lt;execution&gt;
                        &lt;id&gt;test-compile_with_aspectj&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;test-compile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
                        &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
                        &lt;version&gt;${aspectj.runtime.version}&lt;/version&gt;
                    &lt;/dependency&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;some.group.id&lt;/groupId&gt;
                        &lt;artifactId&gt;validation-aspect&lt;/artifactId&gt;
                        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;</code></pre>
<p>For all project now using the <code>aspectParentPOM</code> as their parent, the validationAspect will be woven into all classes implementing the Validatable interface. This means you can perform automatic AspectJ-driven validation in objects inside or outside of any container.</p></section></section>        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2005–2026
<a href="https://www.mojohaus.org">MojoHaus</a>
</p>
        </div>
      </div>
    </footer>
  </body>
</html>